name: Deploy (optional Sonar + auto-rollback)

on:
  workflow_dispatch:
    inputs:
      service:
        description: "Which service to deploy?"
        required: true
        type: choice
        options: [java, node, python]
        default: java
      branch:
        description: "Artifact branch history"
        required: true
        type: choice
        options: [main, develop]
        default: main
      sonar:
        description: "Run SonarQube analysis? (optional, non-blocking)"
        required: true
        type: choice
        options: [yes, no]
        default: no
      approve:
        description: "Proceed with deployment?"
        required: true
        type: choice
        options: [yes, no]
        default: yes

permissions:
  contents: read
  actions: read

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  meta:
    runs-on: ubuntu-latest
    outputs:
      artifact_base: ${{ steps.map.outputs.artifact_base }}
      workflow_file: ${{ steps.map.outputs.workflow_file }}
    steps:
      - name: Map service to workflow and artifact base
        id: map
        run: |
          svc="${{ github.event.inputs.service }}"
          if [ "$svc" = "java" ]; then
            echo "artifact_base=java-build" >> $GITHUB_OUTPUT
            echo "workflow_file=java-ci.yml" >> $GITHUB_OUTPUT
          elif [ "$svc" = "node" ]; then
            echo "artifact_base=node-build" >> $GITHUB_OUTPUT
            echo "workflow_file=node-ci.yml" >> $GITHUB_OUTPUT
          else
            echo "artifact_base=python-build" >> $GITHUB_OUTPUT
            echo "workflow_file=python-ci.yml" >> $GITHUB_OUTPUT
          fi

  resolve_runs:
    needs: [meta]
    runs-on: ubuntu-latest
    outputs:
      latest_run: ${{ steps.pick.outputs.latest_run }}
      prev_run: ${{ steps.pick.outputs.prev_run }}
    steps:
      - name: Pick latest and previous successful CI runs
        id: pick
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const workflow_id = '${{ needs.meta.outputs.workflow_file }}';
            const branch = '${{ github.event.inputs.branch }}';
            const res = await github.rest.actions.listWorkflowRuns({
              owner, repo, workflow_id, branch, status: 'success', per_page: 25
            });
            const runs = res.data.workflow_runs
              .filter(r => r.conclusion === 'success')
              .sort((a,b) => b.run_number - a.run_number);
            if (runs.length === 0) {
              core.setFailed(`No successful runs for ${workflow_id} on ${branch}`);
              return;
            }
            core.setOutput('latest_run', String(runs[0].run_number));
            core.setOutput('prev_run', runs[1] ? String(runs[1].run_number) : '');

  fetch_latest:
    needs: [meta, resolve_runs]
    runs-on: ubuntu-latest
    steps:
      - name: Download latest artifact (by regex name)
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ${{ needs.meta.outputs.workflow_file }}
          run_number: ${{ needs.resolve_runs.outputs.latest_run }}
          # Match "artifact_base-<anything>" (e.g., java-build-15 or java-build)
          name: ^${{ needs.meta.outputs.artifact_base }}(-.*)?$
          name_is_regexp: true
          search_artifacts: true
          path: fetched_artifact
          if_no_artifact_found: fail

      - name: List downloaded files
        run: ls -R fetched_artifact || true

  sonar_optional:
    needs: [fetch_latest]
    runs-on: ubuntu-latest
    steps:
      - name: Sonar skipped
        if: ${{ github.event.inputs.sonar == 'no' }}
        run: echo "Sonar skipped (input=no)."
      - name: Sonar requested (no secrets wired)
        if: ${{ github.event.inputs.sonar == 'yes' }}
        run: |
          echo "Sonar requested. This workflow is secrets-free, so Sonar is not executed."
          echo "Add SONAR_HOST_URL and SONAR_TOKEN later and wire in scan steps if you want."

  gate:
    needs: [sonar_optional]
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.chk.outputs.proceed }}
    steps:
      - name: Check approval input
        id: chk
        run: |
          if [ "${{ github.event.inputs.approve }}" = "yes" ]; then
            echo "proceed=true" >> $GITHUB_OUTPUT
          else
            echo "proceed=false" >> $GITHUB_OUTPUT
            echo "Approval not granted. Stopping."
          fi

  deploy_latest:
    needs: [gate, meta, resolve_runs]
    if: ${{ needs.gate.outputs.proceed == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Download latest artifact (repeat in this job)
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ${{ needs.meta.outputs.workflow_file }}
          run_number: ${{ needs.resolve_runs.outputs.latest_run }}
          name: ^${{ needs.meta.outputs.artifact_base }}(-.*)?$
          name_is_regexp: true
          search_artifacts: true
          path: fetched_artifact
          if_no_artifact_found: fail

      - name: Deploy latest (placeholder)
        run: |
          echo "Deploying '${{ github.event.inputs.service }}' from CI run #${{ needs.resolve_runs.outputs.latest_run }}"
          ls -R fetched_artifact || true
          # Replace below with real deploy commands (helm/kubectl/az/etc).
          # Example:
          #   helm upgrade --install <release> ./chart --set image.tag=${{ needs.resolve_runs.outputs.latest_run }}
          # To test rollback, you can simulate a failure by uncommenting the next line:
          # exit 1
          echo "Latest deploy step finished."

  rollback:
    needs: [deploy_latest, meta, resolve_runs]
    if: ${{ needs.deploy_latest.result == 'failure' && needs.resolve_runs.outputs.prev_run != '' }}
    runs-on: ubuntu-latest
    steps:
      - name: Download previous artifact (by regex)
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ${{ needs.meta.outputs.workflow_file }}
          run_number: ${{ needs.resolve_runs.outputs.prev_run }}
          name: ^${{ needs.meta.outputs.artifact_base }}(-.*)?$
          name_is_regexp: true
          search_artifacts: true
          path: fetched_artifact_prev
          if_no_artifact_found: fail

      - name: Deploy rollback (placeholder)
        run: |
          echo "Rolling back '${{ github.event.inputs.service }}' to CI run #${{ needs.resolve_runs.outputs.prev_run }}"
          ls -R fetched_artifact_prev || true
          # Replace with real rollback commands.
          echo "Rollback step finished."

  no_previous_to_rollback:
    needs: [deploy_latest, resolve_runs]
    if: ${{ needs.deploy_latest.result == 'failure' && needs.resolve_runs.outputs.prev_run == '' }}
    runs-on: ubuntu-latest
    steps:
      - name: No previous success available
        run: |
          echo "Deploy failed and there is no previous successful artifact to roll back to."
          exit 1
